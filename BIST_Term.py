"""
FinTerminal - Professional Financial Statement Analysis
========================================================
A Bloomberg/Koyfin-style financial analysis application built with Streamlit.
Single-file deployable version.

Author: Generated by Claude
Version: 1.0.0
"""

import streamlit as st
import pandas as pd
import numpy as np
import io
import re
from typing import Optional
import warnings
warnings.filterwarnings("ignore")

# ============================================================
# TRANSLATIONS MODULE
# ============================================================

TRANSLATIONS = {
    "EN": {
        "app_title": "FinTerminal",
        "app_subtitle": "Professional Financial Analysis",
        "upload_label": "Upload Financial Statement",
        "upload_help": "Supports Excel (.xlsx, .xls) and CSV files",
        "statement_selector": "Statement Type",
        "period_selector": "Period Filter",
        "scale_selector": "Number Scale",
        "sheet_selector": "Sheet",
        "all_periods": "All Periods",
        "annual": "Annual",
        "quarterly": "Quarterly",
        "scale_full": "Full",
        "scale_thousands": "Thousands",
        "scale_millions": "Millions",
        "stat_rows": "Rows",
        "stat_cols": "Columns",
        "stat_numeric": "Numeric Cols",
        "stat_type": "Statement Type",
        "income": "Income Statement",
        "balance": "Balance Sheet",
        "cashflow": "Cash Flow",
        "other": "Other / Unclassified",
        "no_file": "Upload a financial statement to begin analysis.",
        "no_data": "No data found for selected statement type.",
        "error_file": "Error reading file. Please check the format.",
        "error_empty": "The uploaded file appears to be empty.",
        "footer": "FinTerminal v1.0 ¬∑ Professional Financial Analysis ¬∑ Powered by Python & Streamlit",
        "export_btn": "Export to CSV",
        "export_success": "Table ready for download.",
        "ratios_title": "Quick Ratios",
        "no_ratios": "Insufficient data for ratio calculation.",
        "select_sheet": "Multiple sheets detected. Select a sheet:",
        "classified_as": "Classified as",
        "period_annual": "Annual",
        "period_quarterly": "Quarterly",
        "period_mixed": "Mixed",
        "period_unknown": "Unknown",
        "search_label": "Search rows...",
    },
    "TR": {
        "app_title": "FinTerminal",
        "app_subtitle": "Profesyonel Finansal Analiz",
        "upload_label": "Finansal Tablo Y√ºkle",
        "upload_help": "Excel (.xlsx, .xls) ve CSV dosyalarƒ± desteklenir",
        "statement_selector": "Tablo T√ºr√º",
        "period_selector": "D√∂nem Filtresi",
        "scale_selector": "Sayƒ± √ñl√ßeƒüi",
        "sheet_selector": "Sayfa",
        "all_periods": "T√ºm D√∂nemler",
        "annual": "Yƒ±llƒ±k",
        "quarterly": "√áeyreklik",
        "scale_full": "Tam",
        "scale_thousands": "Bin",
        "scale_millions": "Milyon",
        "stat_rows": "Satƒ±r",
        "stat_cols": "S√ºtun",
        "stat_numeric": "Sayƒ±sal S√ºtun",
        "stat_type": "Tablo T√ºr√º",
        "income": "Gelir Tablosu",
        "balance": "Bilan√ßo",
        "cashflow": "Nakit Akƒ±≈ü Tablosu",
        "other": "Diƒüer / Sƒ±nƒ±flandƒ±rƒ±lmamƒ±≈ü",
        "no_file": "Analizi ba≈ülatmak i√ßin finansal tablo y√ºkleyin.",
        "no_data": "Se√ßili tablo t√ºr√º i√ßin veri bulunamadƒ±.",
        "error_file": "Dosya okunamadƒ±. L√ºtfen formatƒ± kontrol edin.",
        "error_empty": "Y√ºklenen dosya bo≈ü g√∂r√ºn√ºyor.",
        "footer": "FinTerminal v1.0 ¬∑ Profesyonel Finansal Analiz ¬∑ Python & Streamlit",
        "export_btn": "CSV Olarak ƒ∞ndir",
        "export_success": "Tablo indirmeye hazƒ±r.",
        "ratios_title": "Hƒ±zlƒ± Oranlar",
        "no_ratios": "Oran hesaplama i√ßin yetersiz veri.",
        "select_sheet": "Birden fazla sayfa tespit edildi. Sayfa se√ßin:",
        "classified_as": "Sƒ±nƒ±flandƒ±rma",
        "period_annual": "Yƒ±llƒ±k",
        "period_quarterly": "√áeyreklik",
        "period_mixed": "Karma",
        "period_unknown": "Bilinmiyor",
        "search_label": "Satƒ±r ara...",
    }
}

def t(key: str) -> str:
    """Get translation for current language."""
    lang = st.session_state.get("lang", "EN")
    return TRANSLATIONS.get(lang, TRANSLATIONS["EN"]).get(key, key)


# ============================================================
# CLASSIFIER MODULE
# ============================================================

INCOME_KEYWORDS = [
    "revenue", "sales", "net income", "gross profit", "operating profit",
    "ebitda", "ebit", "interest income", "tax", "depreciation",
    "hasƒ±lat", "satƒ±≈ülar", "net kar", "br√ºt kar", "faaliyet karƒ±",
    "amortisman", "vergi", "satƒ±≈ü gelirleri", "toplam gelir",
    "cost of goods", "cogs", "operating expenses", "net profit",
    "earnings", "turnover", "income from operations",
    "satƒ±lan malƒ±n maliyeti", "faaliyet giderleri",
]

BALANCE_KEYWORDS = [
    "assets", "liabilities", "equity", "total assets", "current assets",
    "non-current", "shareholders", "retained earnings", "debt", "receivables",
    "varlƒ±klar", "y√ºk√ºml√ºl√ºkler", "√∂zkaynaklar", "d√∂nen varlƒ±klar",
    "duran varlƒ±klar", "kƒ±sa vadeli", "uzun vadeli", "√∂denmi≈ü sermaye",
    "cash and equivalents", "inventory", "payables", "goodwill",
    "nakit ve nakit benzerleri", "stoklar", "ticari alacaklar",
    "maddi duran varlƒ±klar", "toplam varlƒ±klar",
]

CASHFLOW_KEYWORDS = [
    "cash flow", "operating cash", "investing", "financing",
    "capital expenditure", "capex", "free cash flow", "fcf",
    "nakit akƒ±≈üƒ±", "faaliyetlerden nakit", "yatƒ±rƒ±m faaliyetleri",
    "finansman faaliyetleri", "sermaye harcamalarƒ±", "serbest nakit akƒ±≈üƒ±",
    "net cash", "cash from operations", "net nakit",
]


def score_text(text: str, keywords: list[str]) -> int:
    """Score how many keywords appear in a text string."""
    text_lower = str(text).lower()
    return sum(1 for kw in keywords if kw in text_lower)


def classify_dataframe(df: pd.DataFrame) -> dict[str, pd.DataFrame]:
    """
    Classify rows of a dataframe into financial statement types.
    
    Uses keyword scoring on the first column (label column) and 
    groups consecutive rows into statement blocks.
    
    Returns:
        dict with keys: INCOME, BALANCE, CASHFLOW, OTHER
    
    TODO: Add ML-based classification for better accuracy
    TODO: Add section header detection for multi-statement files
    """
    if df is None or df.empty:
        return {"INCOME": pd.DataFrame(), "BALANCE": pd.DataFrame(),
                "CASHFLOW": pd.DataFrame(), "OTHER": pd.DataFrame()}

    # Use first column as label column
    label_col = df.columns[0]
    
    # Score each row
    row_scores = []
    for _, row in df.iterrows():
        label = str(row[label_col])
        scores = {
            "INCOME": score_text(label, INCOME_KEYWORDS),
            "BALANCE": score_text(label, BALANCE_KEYWORDS),
            "CASHFLOW": score_text(label, CASHFLOW_KEYWORDS),
        }
        best = max(scores, key=scores.get)
        row_scores.append(best if scores[best] > 0 else "OTHER")

    # Assign classification column temporarily
    df = df.copy()
    df["__type__"] = row_scores

    # Also score the entire dataframe for overall classification
    all_text = " ".join(df[label_col].astype(str).tolist()).lower()
    overall = {
        "INCOME": score_text(all_text, INCOME_KEYWORDS),
        "BALANCE": score_text(all_text, BALANCE_KEYWORDS),
        "CASHFLOW": score_text(all_text, CASHFLOW_KEYWORDS),
    }

    # If overall one type dominates strongly, reclassify ambiguous rows
    max_type = max(overall, key=overall.get)
    total = sum(overall.values())
    if total > 0 and overall[max_type] / total > 0.6:
        df["__type__"] = df["__type__"].replace("OTHER", max_type)

    result = {}
    for stmt_type in ["INCOME", "BALANCE", "CASHFLOW", "OTHER"]:
        subset = df[df["__type__"] == stmt_type].drop(columns=["__type__"])
        result[stmt_type] = subset.reset_index(drop=True)

    return result


def classify_sheet(df: pd.DataFrame) -> str:
    """Return the dominant statement type for a full sheet."""
    all_text = " ".join(df.iloc[:, 0].astype(str).tolist()).lower()
    scores = {
        "INCOME": score_text(all_text, INCOME_KEYWORDS),
        "BALANCE": score_text(all_text, BALANCE_KEYWORDS),
        "CASHFLOW": score_text(all_text, CASHFLOW_KEYWORDS),
    }
    best = max(scores, key=scores.get)
    return best if scores[best] > 0 else "OTHER"


# ============================================================
# PERIOD DETECTION MODULE
# ============================================================

QUARTERLY_PATTERNS = [
    r'\bQ[1-4]\b', r'\b[1-4]√á\b', r'\b√á[1-4]\b',
    r'\bMar\b', r'\bJun\b', r'\bSep\b', r'\bDec\b',
    r'\b(Q1|Q2|Q3|Q4)\b',
    r'\b\d{4}[\/\-](0?[369]|12)\b',  # e.g. 2023/03
]

ANNUAL_PATTERNS = [
    r'\b(19|20)\d{2}\b',  # Year like 2020
    r'\bFY\d{2,4}\b',
    r'\bYƒ±l\b', r'\bYear\b',
    r'\bAnnual\b', r'\bYƒ±llƒ±k\b',
]


def detect_period_type(columns: list) -> str:
    """
    Detect whether columns represent annual or quarterly data.
    
    Returns: 'ANNUAL', 'QUARTERLY', 'MIXED', or 'UNKNOWN'
    """
    col_str = " ".join(str(c) for c in columns)
    
    q_hits = sum(1 for pat in QUARTERLY_PATTERNS if re.search(pat, col_str, re.IGNORECASE))
    a_hits = sum(1 for pat in ANNUAL_PATTERNS if re.search(pat, col_str, re.IGNORECASE))

    if q_hits > 0 and a_hits > 0:
        return "MIXED"
    elif q_hits > 0:
        return "QUARTERLY"
    elif a_hits > 0:
        return "ANNUAL"
    return "UNKNOWN"


def filter_columns_by_period(df: pd.DataFrame, period: str) -> pd.DataFrame:
    """
    Filter dataframe columns by period type.
    
    Args:
        df: Input dataframe
        period: 'ANNUAL', 'QUARTERLY', or 'ALL'
    
    Returns:
        Filtered dataframe (label column always kept)
    """
    if period == "ALL" or df.empty:
        return df

    label_col = df.columns[0]
    data_cols = df.columns[1:]
    
    if period == "ANNUAL":
        keep = [c for c in data_cols if any(
            re.search(pat, str(c), re.IGNORECASE) for pat in ANNUAL_PATTERNS
        )]
    elif period == "QUARTERLY":
        keep = [c for c in data_cols if any(
            re.search(pat, str(c), re.IGNORECASE) for pat in QUARTERLY_PATTERNS
        )]
    else:
        keep = list(data_cols)

    if not keep:
        return df  # Don't filter if nothing matches ‚Äî show all

    return df[[label_col] + keep]


# ============================================================
# DATA LOADER MODULE
# ============================================================

def clean_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    """
    Clean a raw dataframe:
    - Drop fully empty rows/columns
    - Strip whitespace from string columns
    - Attempt to parse numeric columns
    
    TODO: Add more sophisticated header detection
    TODO: Handle merged cells better
    """
    # Drop fully empty
    df = df.dropna(how="all").dropna(axis=1, how="all")
    
    if df.empty:
        return df

    # Reset index
    df = df.reset_index(drop=True)

    # If first row looks like a header, promote it
    first_row = df.iloc[0]
    non_null = first_row.notna().sum()
    numeric_count = sum(1 for v in first_row if _is_numeric(v))
    
    if non_null > 1 and numeric_count == 0:
        df.columns = [str(c).strip() for c in first_row]
        df = df.iloc[1:].reset_index(drop=True)
    else:
        df.columns = [str(c).strip() for c in df.columns]

    # Convert numeric columns
    for col in df.columns[1:]:
        df[col] = df[col].apply(_safe_numeric)

    # Strip strings in label column
    df.iloc[:, 0] = df.iloc[:, 0].astype(str).str.strip()
    
    # Remove rows where label is empty/NaN
    df = df[df.iloc[:, 0].notna()]
    df = df[df.iloc[:, 0] != "nan"]
    df = df[df.iloc[:, 0] != ""]
    
    return df.reset_index(drop=True)


def _is_numeric(val) -> bool:
    try:
        float(str(val).replace(",", "").replace(".", "").replace("-", ""))
        return True
    except:
        return False


def _safe_numeric(val):
    """Convert value to numeric if possible, else keep as string."""
    if pd.isna(val):
        return np.nan
    try:
        cleaned = str(val).replace(",", "").replace(" ", "").replace("\xa0", "")
        # Handle parenthetical negatives like (1,234)
        if cleaned.startswith("(") and cleaned.endswith(")"):
            cleaned = "-" + cleaned[1:-1]
        return float(cleaned)
    except:
        return val


@st.cache_data(show_spinner=False)
def load_file(file_bytes: bytes, filename: str) -> dict[str, pd.DataFrame]:
    """
    Load Excel or CSV file and return dict of sheet_name -> dataframe.
    
    Cached to avoid reprocessing on every Streamlit rerun.
    
    TODO: Add support for PDF financial statements via OCR
    TODO: Add Google Sheets URL import
    """
    sheets = {}
    
    try:
        if filename.endswith(".csv"):
            df = pd.read_csv(io.BytesIO(file_bytes), header=None)
            df = clean_dataframe(df)
            sheets["Sheet1"] = df
        else:
            xls = pd.ExcelFile(io.BytesIO(file_bytes))
            for sheet_name in xls.sheet_names:
                df = pd.read_excel(io.BytesIO(file_bytes), sheet_name=sheet_name, header=None)
                df = clean_dataframe(df)
                if not df.empty:
                    sheets[sheet_name] = df
    except Exception as e:
        st.error(f"{t('error_file')}: {e}")
        return {}
    
    if not sheets:
        st.warning(t("error_empty"))
    
    return sheets


# ============================================================
# FORMATTERS MODULE
# ============================================================

SCALE_FACTORS = {
    "Full": 1,
    "Thousands": 1_000,
    "Millions": 1_000_000,
}


def format_dataframe(df: pd.DataFrame, scale: str = "Full") -> pd.DataFrame:
    """
    Format a financial dataframe for display:
    - Scale numeric values
    - Apply thousands separators
    - Preserve string label column
    
    TODO: Add currency detection and symbol display
    TODO: Add color coding for negative values
    """
    if df.empty:
        return df
    
    df = df.copy()
    factor = SCALE_FACTORS.get(scale, 1)
    label_col = df.columns[0]

    for col in df.columns[1:]:
        def fmt_val(v):
            if pd.isna(v):
                return ""
            if isinstance(v, (int, float)):
                scaled = v / factor
                return f"{scaled:,.0f}"
            return str(v)
        df[col] = df[col].apply(fmt_val)

    return df


def get_numeric_df(df: pd.DataFrame) -> pd.DataFrame:
    """Return dataframe with only numeric columns (for ratio/chart computation)."""
    label_col = df.columns[0]
    numeric_cols = [col for col in df.columns[1:] 
                    if pd.to_numeric(df[col], errors='coerce').notna().any()]
    return df[[label_col] + numeric_cols]


def count_numeric_columns(df: pd.DataFrame) -> int:
    """Count columns with numeric data."""
    if df.empty:
        return 0
    count = 0
    for col in df.columns[1:]:
        if pd.to_numeric(df[col], errors='coerce').notna().any():
            count += 1
    return count


# ============================================================
# FINANCIAL RATIOS MODULE (Bonus)
# ============================================================

def compute_quick_ratios(classified: dict[str, pd.DataFrame]) -> dict:
    """
    Compute basic financial ratios from classified statements.
    
    TODO: Expand with full ratio library:
        - Liquidity ratios
        - Profitability ratios
        - Leverage ratios
        - Efficiency ratios
        - Valuation multiples (needs market data)
    """
    ratios = {}
    income = classified.get("INCOME", pd.DataFrame())
    balance = classified.get("BALANCE", pd.DataFrame())

    def find_row(df, keywords):
        if df.empty:
            return None
        label_col = df.columns[0]
        for _, row in df.iterrows():
            label = str(row[label_col]).lower()
            if any(kw.lower() in label for kw in keywords):
                # Get first numeric value
                for col in df.columns[1:]:
                    val = row[col]
                    try:
                        return float(val)
                    except:
                        continue
        return None

    # Try to extract key line items
    revenue = find_row(income, ["revenue", "sales", "hasƒ±lat", "satƒ±≈ülar", "toplam gelir"])
    net_income = find_row(income, ["net income", "net profit", "net kar"])
    gross_profit = find_row(income, ["gross profit", "br√ºt kar"])
    total_assets = find_row(balance, ["total assets", "toplam varlƒ±klar"])
    equity = find_row(balance, ["equity", "√∂zkaynaklar", "shareholders"])
    
    if revenue and net_income:
        ratios["Net Margin"] = f"{(net_income / revenue * 100):.1f}%"
    if revenue and gross_profit:
        ratios["Gross Margin"] = f"{(gross_profit / revenue * 100):.1f}%"
    if net_income and total_assets:
        ratios["ROA"] = f"{(net_income / total_assets * 100):.1f}%"
    if net_income and equity:
        ratios["ROE"] = f"{(net_income / equity * 100):.1f}%"

    return ratios


# ============================================================
# UI STYLES
# ============================================================

DARK_CSS = """
<style>
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap');

/* === GLOBAL === */
html, body, [class*="css"] {
    font-family: 'IBM Plex Sans', sans-serif !important;
}

.stApp {
    background: #0a0c10 !important;
    color: #c9d1d9 !important;
}

/* Hide Streamlit branding */
#MainMenu, footer, header { visibility: hidden; }
.stDeployButton { display: none; }

/* === HEADER BANNER === */
.fin-header {
    background: linear-gradient(135deg, #0d1117 0%, #161b22 50%, #0d1117 100%);
    border-bottom: 1px solid #21262d;
    padding: 16px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin: -1rem -1rem 1.5rem -1rem;
}

.fin-logo {
    font-family: 'IBM Plex Mono', monospace !important;
    font-size: 1.4rem;
    font-weight: 600;
    color: #58a6ff;
    letter-spacing: 2px;
    text-transform: uppercase;
}

.fin-logo span {
    color: #3fb950;
}

.fin-subtitle {
    font-size: 0.75rem;
    color: #6e7681;
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-top: 2px;
}

/* === STAT CARDS === */
.stat-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    margin: 1rem 0;
}

.stat-card {
    background: #161b22;
    border: 1px solid #21262d;
    border-radius: 6px;
    padding: 14px 16px;
    transition: border-color 0.2s;
}

.stat-card:hover { border-color: #30363d; }

.stat-label {
    font-size: 0.68rem;
    color: #6e7681;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-family: 'IBM Plex Mono', monospace;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 600;
    color: #e6edf3;
    font-family: 'IBM Plex Mono', monospace;
    margin-top: 4px;
}

.stat-value.accent { color: #58a6ff; }
.stat-value.green { color: #3fb950; }
.stat-value.yellow { color: #d29922; }

/* === TABLE STYLES === */
.stDataFrame {
    border: 1px solid #21262d !important;
    border-radius: 6px !important;
    overflow: hidden !important;
}

.stDataFrame thead th {
    background: #161b22 !important;
    color: #8b949e !important;
    font-family: 'IBM Plex Mono', monospace !important;
    font-size: 0.75rem !important;
    text-transform: uppercase !important;
    letter-spacing: 0.5px !important;
    border-bottom: 1px solid #30363d !important;
}

.stDataFrame tbody tr {
    border-bottom: 1px solid #161b22 !important;
}

.stDataFrame tbody tr:hover td {
    background: #1c2128 !important;
}

.stDataFrame tbody td {
    font-family: 'IBM Plex Mono', monospace !important;
    font-size: 0.82rem !important;
    color: #c9d1d9 !important;
    padding: 6px 12px !important;
}

.stDataFrame tbody td:first-child {
    color: #e6edf3 !important;
    font-weight: 500 !important;
}

/* === CONTROLS === */
.stSelectbox > div > div {
    background: #161b22 !important;
    border: 1px solid #30363d !important;
    border-radius: 6px !important;
    color: #c9d1d9 !important;
}

.stFileUploader {
    background: #161b22 !important;
    border: 1px dashed #30363d !important;
    border-radius: 6px !important;
    padding: 1rem !important;
}

/* === SECTION TITLES === */
.section-title {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.7rem;
    color: #6e7681;
    text-transform: uppercase;
    letter-spacing: 2px;
    border-bottom: 1px solid #21262d;
    padding-bottom: 8px;
    margin: 1.5rem 0 1rem 0;
}

/* === BADGE === */
.badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.7rem;
    font-weight: 500;
    letter-spacing: 0.5px;
}

.badge-blue { background: #1f3a5f; color: #58a6ff; border: 1px solid #1f6feb; }
.badge-green { background: #1a3a2a; color: #3fb950; border: 1px solid #238636; }
.badge-yellow { background: #3a2a00; color: #d29922; border: 1px solid #9e6a03; }
.badge-gray { background: #21262d; color: #8b949e; border: 1px solid #30363d; }

/* === RATIO CARDS === */
.ratio-grid {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin: 0.5rem 0 1rem 0;
}

.ratio-card {
    background: #161b22;
    border: 1px solid #21262d;
    border-radius: 6px;
    padding: 10px 16px;
    min-width: 120px;
}

.ratio-name {
    font-size: 0.65rem;
    color: #6e7681;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-family: 'IBM Plex Mono', monospace;
}

.ratio-val {
    font-size: 1.1rem;
    font-weight: 600;
    color: #3fb950;
    font-family: 'IBM Plex Mono', monospace;
    margin-top: 2px;
}

/* === FOOTER === */
.fin-footer {
    margin-top: 3rem;
    padding: 16px 0;
    border-top: 1px solid #21262d;
    text-align: center;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    color: #484f58;
    letter-spacing: 1px;
    text-transform: uppercase;
}

/* === EMPTY STATE === */
.empty-state {
    text-align: center;
    padding: 4rem 2rem;
    color: #6e7681;
}

.empty-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.3;
}

.empty-text {
    font-size: 0.9rem;
    letter-spacing: 0.5px;
}

/* === UPLOAD ZONE === */
.upload-zone {
    border: 1px dashed #30363d;
    border-radius: 8px;
    background: #0d1117;
    padding: 2rem;
    text-align: center;
}

/* Period badge */
.period-badge {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    vertical-align: middle;
}

/* Scrollable table container */
.table-container {
    overflow-x: auto;
    border-radius: 6px;
    border: 1px solid #21262d;
}

/* Trend arrows */
.trend-up { color: #3fb950; }
.trend-down { color: #f85149; }

div[data-testid="stMetric"] {
    background: #161b22;
    border: 1px solid #21262d;
    border-radius: 6px;
    padding: 12px 16px;
}

div[data-testid="stMetric"] label {
    color: #6e7681 !important;
    font-family: 'IBM Plex Mono', monospace !important;
    font-size: 0.7rem !important;
    text-transform: uppercase !important;
    letter-spacing: 1px !important;
}

div[data-testid="stMetricValue"] {
    color: #e6edf3 !important;
    font-family: 'IBM Plex Mono', monospace !important;
}

/* Sidebar */
section[data-testid="stSidebar"] {
    background: #0d1117 !important;
    border-right: 1px solid #21262d !important;
}

/* Button */
.stButton button {
    background: #1f3a5f !important;
    color: #58a6ff !important;
    border: 1px solid #1f6feb !important;
    border-radius: 6px !important;
    font-family: 'IBM Plex Mono', monospace !important;
    font-size: 0.75rem !important;
    letter-spacing: 1px !important;
}

.stButton button:hover {
    background: #1f6feb !important;
    color: #ffffff !important;
}

/* Text input */
.stTextInput input {
    background: #161b22 !important;
    border: 1px solid #30363d !important;
    color: #c9d1d9 !important;
    border-radius: 6px !important;
    font-family: 'IBM Plex Mono', monospace !important;
    font-size: 0.82rem !important;
}

/* Radio */
.stRadio label {
    color: #c9d1d9 !important;
    font-size: 0.85rem !important;
}
</style>
"""


# ============================================================
# UI HELPERS
# ============================================================

def render_header():
    st.markdown(f"""
    <div class="fin-header">
        <div>
            <div class="fin-logo">Fin<span>Terminal</span></div>
            <div class="fin-subtitle">{t('app_subtitle')}</div>
        </div>
        <div style="font-family: 'IBM Plex Mono', monospace; font-size: 0.7rem; color: #484f58;">
            ALPHA ¬∑ v1.0.0
        </div>
    </div>
    """, unsafe_allow_html=True)


def render_stat_cards(df: pd.DataFrame, stmt_type: str, period_type: str):
    type_colors = {
        "INCOME": ("accent", "üíπ"),
        "BALANCE": ("yellow", "üìä"),
        "CASHFLOW": ("green", "üí∞"),
        "OTHER": ("", "üìÑ"),
    }
    color, icon = type_colors.get(stmt_type, ("", "üìÑ"))
    type_label = t(stmt_type.lower()) if stmt_type.lower() in ["income", "balance", "cashflow", "other"] else stmt_type
    
    num_cols = count_numeric_columns(df)
    
    st.markdown(f"""
    <div class="stat-grid">
        <div class="stat-card">
            <div class="stat-label">{t('stat_rows')}</div>
            <div class="stat-value">{len(df):,}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">{t('stat_cols')}</div>
            <div class="stat-value">{len(df.columns):,}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">{t('stat_numeric')}</div>
            <div class="stat-value accent">{num_cols}</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">{t('stat_type')}</div>
            <div class="stat-value" style="font-size:1rem; margin-top: 8px;">
                {icon} {type_label}
            </div>
        </div>
    </div>
    """, unsafe_allow_html=True)


def render_period_badge(period_type: str):
    badge_map = {
        "ANNUAL": ("badge-blue", t("period_annual")),
        "QUARTERLY": ("badge-green", t("period_quarterly")),
        "MIXED": ("badge-yellow", t("period_mixed")),
        "UNKNOWN": ("badge-gray", t("period_unknown")),
    }
    cls, label = badge_map.get(period_type, ("badge-gray", period_type))
    return f'<span class="badge {cls}">{label}</span>'


def render_ratios(ratios: dict):
    if not ratios:
        return
    
    st.markdown(f'<div class="section-title">‚ö° {t("ratios_title")}</div>', unsafe_allow_html=True)
    cards = "".join(
        f'<div class="ratio-card"><div class="ratio-name">{k}</div><div class="ratio-val">{v}</div></div>'
        for k, v in ratios.items()
    )
    st.markdown(f'<div class="ratio-grid">{cards}</div>', unsafe_allow_html=True)


def render_footer():
    st.markdown(f'<div class="fin-footer">{t("footer")}</div>', unsafe_allow_html=True)


def render_empty_state():
    st.markdown(f"""
    <div class="empty-state">
        <div class="empty-icon">üìà</div>
        <div class="empty-text">{t('no_file')}</div>
    </div>
    """, unsafe_allow_html=True)


# ============================================================
# MAIN APPLICATION
# ============================================================

def main():
    st.set_page_config(
        page_title="FinTerminal",
        page_icon="üìà",
        layout="wide",
        initial_sidebar_state="collapsed",
    )

    # Inject CSS
    st.markdown(DARK_CSS, unsafe_allow_html=True)

    # Initialize session state
    if "lang" not in st.session_state:
        st.session_state.lang = "EN"
    if "classified" not in st.session_state:
        st.session_state.classified = None
    if "active_sheet" not in st.session_state:
        st.session_state.active_sheet = None

    # === LANGUAGE SELECTOR (top right) ===
    col_title, col_lang = st.columns([10, 1])
    with col_lang:
        lang_choice = st.selectbox("üåê", ["EN", "TR"], 
                                    index=0 if st.session_state.lang == "EN" else 1,
                                    label_visibility="collapsed")
        st.session_state.lang = lang_choice

    # === HEADER ===
    render_header()

    # === SIDEBAR CONTROLS ===
    with st.sidebar:
        st.markdown('<div class="section-title">Controls</div>', unsafe_allow_html=True)
        
        uploaded_file = st.file_uploader(
            t("upload_label"),
            type=["xlsx", "xls", "csv"],
            help=t("upload_help")
        )

        # Scale selector
        scale_options = {
            t("scale_full"): "Full",
            t("scale_thousands"): "Thousands",
            t("scale_millions"): "Millions",
        }
        scale_label = st.selectbox(t("scale_selector"), list(scale_options.keys()))
        scale = scale_options[scale_label]

        # Search filter
        search_query = st.text_input(t("search_label"), placeholder="...")

    # === PROCESS FILE ===
    sheets = {}
    if uploaded_file:
        file_bytes = uploaded_file.read()
        sheets = load_file(file_bytes, uploaded_file.name)

    # === MAIN CONTENT ===
    if not sheets:
        render_empty_state()
        render_footer()
        return

    # Sheet selector (if multiple)
    sheet_names = list(sheets.keys())
    if len(sheet_names) > 1:
        st.markdown(f'<div class="section-title">{t("select_sheet")}</div>', unsafe_allow_html=True)
        selected_sheet = st.radio(t("sheet_selector"), sheet_names, horizontal=True, 
                                   label_visibility="collapsed")
    else:
        selected_sheet = sheet_names[0]

    raw_df = sheets[selected_sheet]

    # Classify
    classified = classify_dataframe(raw_df)
    overall_type = classify_sheet(raw_df)

    # Period detection
    period_type = detect_period_type(list(raw_df.columns))

    # === CONTROL STRIP ===
    col1, col2, col3 = st.columns([2, 2, 2])

    with col1:
        stmt_options = {
            t("income"): "INCOME",
            t("balance"): "BALANCE",
            t("cashflow"): "CASHFLOW",
            t("other"): "OTHER",
        }
        # Pre-select the detected type
        default_idx = list(stmt_options.values()).index(overall_type) if overall_type in stmt_options.values() else 0
        stmt_label = st.selectbox(t("statement_selector"), list(stmt_options.keys()), index=default_idx)
        selected_stmt = stmt_options[stmt_label]

    with col2:
        period_opts = {
            t("all_periods"): "ALL",
            t("annual"): "ANNUAL",
            t("quarterly"): "QUARTERLY",
        }
        period_label = st.selectbox(t("period_selector"), list(period_opts.keys()))
        selected_period = period_opts[period_label]

    with col3:
        # Display period detection result
        st.markdown(f"""
        <div style="padding-top: 28px; font-family: 'IBM Plex Mono', monospace; font-size: 0.72rem; color: #6e7681;">
            {t('classified_as')}: {render_period_badge(period_type)}
        </div>
        """, unsafe_allow_html=True)

    # === GET DISPLAY DATA ===
    display_df = classified.get(selected_stmt, pd.DataFrame())

    # If selected type is empty, fall back to full dataframe
    if display_df.empty:
        display_df = raw_df

    # Period filter
    display_df = filter_columns_by_period(display_df, selected_period)

    # Search filter
    if search_query.strip() and not display_df.empty:
        label_col = display_df.columns[0]
        mask = display_df[label_col].astype(str).str.lower().str.contains(
            search_query.lower(), na=False
        )
        display_df = display_df[mask]

    # === STAT CARDS ===
    if not display_df.empty:
        render_stat_cards(display_df, selected_stmt, period_type)

    # === QUICK RATIOS (Bonus) ===
    ratios = compute_quick_ratios(classified)
    if ratios:
        render_ratios(ratios)

    # === TABLE ===
    st.markdown(f'<div class="section-title">üìã {stmt_label}</div>', unsafe_allow_html=True)

    if display_df.empty:
        st.info(t("no_data"))
    else:
        formatted_df = format_dataframe(display_df, scale)
        
        # Style the dataframe
        st.dataframe(
            formatted_df,
            use_container_width=True,
            height=min(600, max(200, len(formatted_df) * 35 + 60)),
            hide_index=True,
        )

        # === EXPORT ===
        col_exp, _ = st.columns([1, 4])
        with col_exp:
            csv_data = formatted_df.to_csv(index=False).encode("utf-8-sig")
            st.download_button(
                label=t("export_btn"),
                data=csv_data,
                file_name=f"{selected_sheet}_{selected_stmt}.csv",
                mime="text/csv",
            )

        # === TREND CHART (Bonus) ===
        numeric_df = get_numeric_df(display_df)
        if len(numeric_df.columns) > 2:
            with st.expander("üìà Trend View", expanded=False):
                label_col = numeric_df.columns[0]
                data_cols = list(numeric_df.columns[1:])
                
                # Select rows to chart
                row_opts = numeric_df[label_col].tolist()
                selected_rows = st.multiselect("Select line items", row_opts, 
                                                default=row_opts[:min(3, len(row_opts))])
                
                if selected_rows:
                    chart_data = numeric_df[numeric_df[label_col].isin(selected_rows)]
                    chart_df = chart_data[data_cols].T
                    chart_df.columns = selected_rows
                    chart_df.index = data_cols
                    
                    try:
                        chart_df = chart_df.apply(pd.to_numeric, errors='coerce')
                        st.line_chart(chart_df, use_container_width=True, height=300)
                    except Exception:
                        st.info("Could not render chart for selected data.")

    # === FOOTER ===
    render_footer()


if __name__ == "__main__":
    main()
